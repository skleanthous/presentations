"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _markdownItFrontMatter = _interopRequireDefault(require("markdown-it-front-matter"));

var _plugin = _interopRequireDefault(require("../../plugin"));

var _comment = require("../comment");

var directives = _interopRequireWildcard(require("./directives"));

var _yaml = _interopRequireDefault(require("./yaml"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const isDirectiveComment = token => token.type === 'marpit_comment' && token.meta.marpitParsedDirectives;
/**
 * Parse Marpit directives and store result to the slide token meta.
 *
 * Marpit comment plugin ans slide plugin requires already loaded to
 * markdown-it instance.
 *
 * @alias module:markdown/directives/parse
 * @param {MarkdownIt} md markdown-it instance.
 * @param {Object} [opts]
 * @param {boolean} [opts.frontMatter=true] Switch feature to support YAML
 *     front-matter. If true, you can use Jekyll style directive setting to the
 *     first page.
 */


function parse(md, opts = {}) {
  const {
    marpit
  } = md;

  const applyBuiltinDirectives = (newProps, builtinDirectives) => {
    let ret = {};

    for (const prop of Object.keys(newProps)) {
      if (builtinDirectives[prop]) {
        ret = _objectSpread(_objectSpread({}, ret), builtinDirectives[prop](newProps[prop], marpit));
      } else {
        ret[prop] = newProps[prop];
      }
    }

    return ret;
  }; // Front-matter support


  const frontMatter = opts.frontMatter === undefined ? true : !!opts.frontMatter;
  let frontMatterObject = {};

  if (frontMatter) {
    md.core.ruler.before('block', 'marpit_directives_front_matter', state => {
      frontMatterObject = {};
      if (!state.inlineMode) marpit.lastGlobalDirectives = {};
    });
    md.use(_markdownItFrontMatter.default, fm => {
      frontMatterObject.text = fm;
      const parsed = (0, _yaml.default)(fm, marpit.options.looseYAML ? [...Object.keys(marpit.customDirectives.global), ...Object.keys(marpit.customDirectives.local)] : false);
      if (parsed !== false) frontMatterObject.yaml = parsed;
    });
  } // Parse global directives


  md.core.ruler.after('inline', 'marpit_directives_global_parse', state => {
    if (state.inlineMode) return;
    let globalDirectives = {};

    const applyDirectives = obj => {
      let recognized = false;

      for (const key of Object.keys(obj)) {
        if (directives.globals[key]) {
          recognized = true;
          globalDirectives = _objectSpread(_objectSpread({}, globalDirectives), directives.globals[key](obj[key], marpit));
        } else if (marpit.customDirectives.global[key]) {
          recognized = true;
          globalDirectives = _objectSpread(_objectSpread({}, globalDirectives), applyBuiltinDirectives(marpit.customDirectives.global[key](obj[key], marpit), directives.globals));
        }
      }

      return recognized;
    };

    if (frontMatterObject.yaml) applyDirectives(frontMatterObject.yaml);

    for (const token of state.tokens) {
      if (isDirectiveComment(token) && applyDirectives(token.meta.marpitParsedDirectives)) {
        (0, _comment.markAsParsed)(token, 'directive');
      } else if (token.type === 'inline') {
        for (const t of token.children) {
          if (isDirectiveComment(t) && applyDirectives(t.meta.marpitParsedDirectives)) (0, _comment.markAsParsed)(t, 'directive');
        }
      }
    }

    marpit.lastGlobalDirectives = _objectSpread({}, globalDirectives);
  }); // Parse local directives and apply meta to slide

  md.core.ruler.after('marpit_slide', 'marpit_directives_parse', state => {
    if (state.inlineMode) return;
    const slides = [];
    const cursor = {
      slide: undefined,
      local: {},
      spot: {}
    };

    const applyDirectives = obj => {
      let recognized = false;

      for (const key of Object.keys(obj)) {
        if (directives.locals[key]) {
          recognized = true;
          cursor.local = _objectSpread(_objectSpread({}, cursor.local), directives.locals[key](obj[key], marpit));
        } else if (marpit.customDirectives.local[key]) {
          recognized = true;
          cursor.local = _objectSpread(_objectSpread({}, cursor.local), applyBuiltinDirectives(marpit.customDirectives.local[key](obj[key], marpit), directives.locals));
        } // Spot directives
        // (Apply local directive to only current slide by prefix "_")


        if (key.startsWith('_')) {
          const spotKey = key.slice(1);

          if (directives.locals[spotKey]) {
            recognized = true;
            cursor.spot = _objectSpread(_objectSpread({}, cursor.spot), directives.locals[spotKey](obj[key], marpit));
          } else if (marpit.customDirectives.local[spotKey]) {
            recognized = true;
            cursor.spot = _objectSpread(_objectSpread({}, cursor.spot), applyBuiltinDirectives(marpit.customDirectives.local[spotKey](obj[key], marpit), directives.locals));
          }
        }
      }

      return recognized;
    };

    if (frontMatterObject.yaml) applyDirectives(frontMatterObject.yaml);

    for (const token of state.tokens) {
      if (token.meta && token.meta.marpitSlideElement === 1) {
        // Initialize Marpit directives meta
        token.meta.marpitDirectives = {};
        slides.push(token);
        cursor.slide = token;
      } else if (token.meta && token.meta.marpitSlideElement === -1) {
        // Assign local and spot directives to meta
        cursor.slide.meta.marpitDirectives = _objectSpread(_objectSpread(_objectSpread({}, cursor.slide.meta.marpitDirectives), cursor.local), cursor.spot);
        cursor.spot = {};
      } else if (isDirectiveComment(token) && applyDirectives(token.meta.marpitParsedDirectives)) {
        (0, _comment.markAsParsed)(token, 'directive');
      } else if (token.type === 'inline') {
        for (const t of token.children) {
          if (isDirectiveComment(t) && applyDirectives(t.meta.marpitParsedDirectives)) (0, _comment.markAsParsed)(t, 'directive');
        }
      }
    } // Assign global directives to meta


    for (const token of slides) token.meta.marpitDirectives = _objectSpread(_objectSpread({}, token.meta.marpitDirectives), marpit.lastGlobalDirectives);
  });
}

var _default = (0, _plugin.default)(parse);

exports.default = _default;