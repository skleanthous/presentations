"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _split = _interopRequireDefault(require("../helpers/split"));

var _wrap_tokens = _interopRequireDefault(require("../helpers/wrap_tokens"));

var _plugin = _interopRequireDefault(require("../plugin"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Marpit slide plugin.
 *
 * Split markdown-it tokens into the slides by horizontal rule. Each slides
 * will be wrapped by section element.
 *
 * @alias module:markdown/slide
 * @param {MarkdownIt} md markdown-it instance.
 * @param {Object} [opts]
 * @param {Object} [opts.attributes] The `<section>` element attributes by
 *     key-value pairs.
 * @param {(boolean|anchorCallback)} [opts.anchor=true] If true, assign the
 *     anchor with the page number starting from 1. You can customize anchor
 *     name by passing callback function.
 */
function slide(md, opts = {}) {
  const anchor = opts.anchor === undefined ? true : opts.anchor;
  /**
   * Convert slide page index into anchor string.
   *
   * @callback anchorCallback
   * @param {number} index Slide page index, beginning from zero.
   * @returns {string} The text of anchor/id attribute (without prefix `#`).
   */

  const anchorCallback = typeof anchor === 'function' ? anchor : i => anchor ? `${i + 1}` : undefined;
  md.core.ruler.push('marpit_slide', state => {
    if (state.inlineMode) return;
    const splittedTokens = (0, _split.default)(state.tokens, t => t.type === 'hr' && t.level === 0, true);
    const {
      length: marpitSlideTotal
    } = splittedTokens;
    state.tokens = splittedTokens.reduce((arr, slideTokens, marpitSlide) => {
      const firstHr = slideTokens[0] && slideTokens[0].type === 'hr' ? slideTokens[0] : undefined;
      const mapTarget = firstHr || slideTokens.find(t => t.map);
      return [...arr, ...(0, _wrap_tokens.default)(state.Token, 'marpit_slide', _objectSpread(_objectSpread({}, opts.attributes || {}), {}, {
        tag: 'section',
        id: anchorCallback(marpitSlide),
        open: {
          block: true,
          meta: {
            marpitSlide,
            marpitSlideTotal,
            marpitSlideElement: 1
          },
          map: mapTarget ? mapTarget.map : [0, 1]
        },
        close: {
          block: true,
          meta: {
            marpitSlide,
            marpitSlideTotal,
            marpitSlideElement: -1
          }
        }
      }), slideTokens.slice(firstHr ? 1 : 0))];
    }, []);
  });
}

var _default = (0, _plugin.default)(slide);

exports.default = _default;